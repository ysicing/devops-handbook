[{"content":" AdGuard Home使用Golang开发，因此安装非常简单，这里以容器的方式部署为例，其它方式可参考官方帮助文档。\n 主要功能  拦截AD 号称隐私保护 家庭保护模式 自定义过滤(劫持) (😂我用的最多的是这个)  部署 二话不说直接上\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  # docker-compose.yamlversion:\u0026#39;2.1\u0026#39;services:caddy:image:spanda/caddycontainer_name:caddyvolumes:- ./ssl:/root/.caddy- /var/log/caddy:/var/log/caddy- ./Caddyfile:/etc/Caddyfilenetwork_mode:hostrestart:alwaysdns:image:adguard/adguardhomecontainer_name:dnsvolumes:- ./ad/conf:/opt/adguardhome/conf- ./ad/work:/opt/adguardhome/worknetwork_mode:hostrestart:always# Caddyfiledns.ysicing.net{gziptlsroot@ysicing.netlog//var/log/caddy/dns.ysicing.net.log\u0026#34;{remote} {when} {method} {uri} {proto} {status} {size} {\u0026gt;User-Agent} {latency}\u0026#34;{rotate_size50rotate_age90rotate_keep20rotate_compress}header/{Strict-Transport-Security\u0026#34;max-age=31536000;includeSubDomains;preload\u0026#34;Access-Control-Allow-Origin*Access-Control-Allow-Methods\u0026#34;GET, POST, OPTIONS\u0026#34;-Server}proxy/127.0.0.1:7070{transparentwebsocket}}  访问公网IP:3000,按着无脑一顿猛操作。修改默认web监听端口为127.0.0.1:7070,53端口默认监听全部。\n使用 Windows  打开网络和Internet设置 打开网络和共享中心 打开以太网 打开属性 编辑TCP/IPV4 使用下面的DNS服务器 首 59.110.220.53 备 8.8.8.8  Mac 跳过很简单\n安卓 自己折腾吧，私有dns搞不定，官方APP可以\n","description":"AdGuard使用姿势","id":2,"section":"posts","tags":["dns","AdGuard"],"title":"AdGuard使用姿势","uri":"https://ysicing.me/posts/dns-adguard-install/"},{"content":" 上周有遇到过这个问题 awk '{print $$1}' 这个$$是什么用法呢\n 间接字段寻址,其类似\nawk '{print $$1}' ===\u0026gt; awk '{print $($1)}' ===\u0026gt; awk '{Nr=$1; print $Nr}' 示例:\n$ echo -e \u0026quot;1 b c d\\n2 b c d\\n3 b c d\\n4 b c d\u0026quot; 1 b c d 2 b c d 3 b c d 4 b c d $ echo -e \u0026quot;1 b c d\\n2 b c d\\n3 b c d\\n4 b c d\u0026quot; | awk '{print $$1}' 1 # since filed #1=1 result print first field b # since filed #1=2 result print secondfield c # since filed #1=3 result print third field d # since filed #1=4 result print fourth field 类似$可以根据需要添加更多\nawk '{print $$$1}' ===\u0026gt; awk '{print $$($1)}' ===\u0026gt; awk '{print $($($1))}' ","description":"awk 中关于多个$的用法","id":3,"section":"posts","tags":["shell"],"title":"awk 中关于多个$的用法","uri":"https://ysicing.me/posts/awk-func/"},{"content":" 操作有风险\n 更新源  需要移除默认源，使用如下源\n # 默认 cat \u0026gt;/etc/apt/sources.list \u0026lt;\u0026lt;EOF deb http://mirrors.ustc.edu.cn/debian/ buster main contrib non-free deb http://mirrors.ustc.edu.cn/debian/debian/ buster-updates main contrib non-free deb http://mirrors.ustc.edu.cn/debian/ buster-backports main contrib non-free deb http://mirrors.ustc.edu.cn/debian-security/ buster/updates main contrib non-free EOF # Ucloud cat \u0026gt;/etc/apt/sources.list \u0026lt;\u0026lt;EOF deb http://mirrors.ucloud.cn/debian/ buster main contrib non-free deb http://mirrors.ucloud.cn/debian/ buster-updates main contrib non-free deb http://mirrors.ucloud.cn/debian/ buster-backports main contrib non-free deb http://mirrors.ucloud.cn/debian-security/ buster/updates main contrib non-free EOF 更新升级\n1 2  apt update apt dist-upgrade -y   升级到最新内核 apt-get install -t buster-backports linux-image-amd64 -y update-grub apt autoclean apt autoremove -y reboot ","description":"Debian 10操作指南","id":4,"section":"posts","tags":["debian",""],"title":"Debian 10操作指南","uri":"https://ysicing.me/posts/debian-buster-op/"},{"content":"安装 curl -fsSL https://ysicing.me/hack/docker/install.sh | bash 或者 ergo install docker -h 做了如下设置\n1 2 3 4 5 6 7 8 9 10 11 12 13  { \u0026#34;exec-opts\u0026#34;: [\u0026#34;native.cgroupdriver=systemd\u0026#34;], \u0026#34;registry-mirrors\u0026#34;: [\u0026#34;https://reg-mirror.qiniu.com\u0026#34;,\u0026#34;https://dyucrs4l.mirror.aliyuncs.com\u0026#34;,\u0026#34;https://dockerhub.azk8s.cn\u0026#34;], \u0026#34;bip\u0026#34;: \u0026#34;169.254.0.1/24\u0026#34;, \u0026#34;max-concurrent-downloads\u0026#34;: 10, \u0026#34;log-driver\u0026#34;: \u0026#34;json-file\u0026#34;, \u0026#34;log-level\u0026#34;: \u0026#34;warn\u0026#34;, \u0026#34;log-opts\u0026#34;: { \u0026#34;max-size\u0026#34;: \u0026#34;20m\u0026#34;, \u0026#34;max-file\u0026#34;: \u0026#34;2\u0026#34; }, \u0026#34;storage-driver\u0026#34;: \u0026#34;overlay2\u0026#34; }   docker常用工具安装 docker run --rm -v /usr/local/bin:/sysdir ysicing/tools tar zxf /pkg.tgz -C /sysdir 内置了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  etcdctl helm(v3) helminit // 初始化helm, 默认配置的是mirror.azure.cn docker-compose calicoctl ctop cclear (清理退出容器) din (进入容器 din \u0026lt;cname/\u0026gt;cid\u0026gt; ash/bash(默认)/sh) dps (容器状态) etcdcli (特别支持k8s集群的etcd) kbtoken (查看kuboard admin用户token) kdtoken (查看dashboard-admin 用户token) istioctl linkerd upgrade-tools // 升级二进制   ","description":"docker快速安装","id":5,"section":"posts","tags":["docker","安装"],"title":"docker快速安装","uri":"https://ysicing.me/posts/docker-install/"},{"content":"变量和常量 关键字\u0026amp;保留字\n# 25个保留字 break default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var # 37个保留字 Constants: true false iota nil Types: int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr float32 float64 complex128 complex64 bool byte rune string error Functions: make len cap new append copy close delete complex real imag panic recover 注意\n1. 函数外的每个语句都必须以关键字开始（var、const、func等） 2. :=不能使用在函数外。 3. _多用于占位，表示忽略值(匿名变量，不占用命名空间，不会分配内存，不需要存在重复申明) 变量 1 2 3 4 5 6 7 8 9 10 11 12 13  package main import ( \u0026#34;fmt\u0026#34; ) // 全局变量m var m = 100 func main() { n := 10 m := 200 // 此处声明局部变量m \tfmt.Println(m, n) }   常量 常量是恒定不变的值\n1 2 3 4 5 6 7 8  const pi = 3.1415 const ( // const声明多个常量时，如果省略了值则表示和上面一行的值相同  p1 = 3.1415 p2 // 3.1415  p3 // 3.1415 )   iota iota是go语言的常量计数器，只能在常量的表达式中使用。iota在const关键字出现时将被重置为0。const中每新增一行常量声明将使iota计数一次(iota可理解为const语句块中的行索引)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  const ( n1 = iota // 0  n2 // 1  n3 // 2  _ // 跳过某些值  n4 // 3  n5 = 10 // 10  n6 // 4 ) const ( _ = iota // 0  KB = 1 \u0026lt;\u0026lt; (10 * iota) // 1 1\u0026lt;\u0026lt;10 2^10 1024  MB = 1 \u0026lt;\u0026lt; (10 * iota) // 2 1\u0026lt;\u0026lt;20 2^20 1024*1024 ) const ( a, b = iota + 1, iota + 2 // 1,2  c, d // 2, 3 )   基本数据类型 package main import ( \u0026quot;fmt\u0026quot; \u0026quot;math\u0026quot; ) func main() { var a int = 17 // int 型 (int64) fmt.Printf(\u0026quot;%d \\n\u0026quot;, a) // 17 十进制 fmt.Printf(\u0026quot;%b \\n\u0026quot;, a) // 10001 二进制 fmt.Printf(\u0026quot;%o \\n\u0026quot;, a) // 021 八进制 fmt.Printf(\u0026quot;%x \\n\u0026quot;, a) // 0x11 16禁止 fmt.Printf(\u0026quot;%.2f \\n\u0026quot;, math.Pi) // 默认都是浮点型float64 var s = \u0026quot;666\u0026quot; fmt.Printf(\u0026quot;%T \\n\u0026quot;, s) // 类型 string fmt.Printf(\u0026quot;%v \\n\u0026quot;, s) // 值 666 fmt.Printf(\u0026quot;%#v \\n\u0026quot;, s) // 值 \u0026quot;666\u0026quot; } 注:\n布尔类型变量的默认值为false。 Go 语言中不允许将整型强制转换为布尔型. 布尔型无法参与数值运算，也无法与其他类型进行转换 字符串 字符串需要使用\u0026quot;\ns1 := \u0026quot;ysicing\u0026quot; 多行字符串需要使用```\ns1 := `牛 牛 牛 牛 ` 字符串操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  package main import ( \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; ) func main() { a := \u0026#34;666\u0026#34; b := \u0026#34;777\u0026#34; c := a + \u0026#34;-\u0026#34; + b fmt.Println(len(a)) // len 长度 \tfmt.Println(fmt.Sprintf(\u0026#34;%s%s\u0026#34;, a, b)) // 拼接 \tfmt.Println(a + b) // 拼接 \tfmt.Print(strings.Split(c, \u0026#34;-\u0026#34;)[0]) // 分割 \tres := strings.Split(c, \u0026#34;-\u0026#34;) // 分割 \tfmt.Println(res) fmt.Println(strings.HasPrefix(c, \u0026#34;6\u0026#34;), strings.HasSuffix(c, \u0026#34;6\u0026#34;)) //前缀/后缀判断  s := \u0026#34;China万岁\u0026#34; for i := 0; i \u0026lt; len(s); i++ { // byte \tfmt.Printf(\u0026#34;%T %v(%c) \\n\u0026#34;, s[i], s[i], s[i]) } fmt.Println() for _, j := range s { // rune \tfmt.Printf(\u0026#34;%T %v(%c) \\n\u0026#34;, j, j, j) } fmt.Println() }    uint8类型, 或者叫 byte型 代表了ASCII码的一个字符. rune类型, 代表一个 UTF-8字符(中文), 实际是一个int32. 因为UTF8编码下一个中文汉字由3~4个字节组成,一个rune字符由一个或多个byte组成.  流程控制 if if 表达式1 { 分支1 } else if 表达式2 { 分支2 } else{ 分支3 } for 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  package main import \u0026#34;fmt\u0026#34; func main() { // 基本格式 \tfor i := 1; i \u0026lt;= 3; i++ { fmt.Println(i) } j := 1 for ; j \u0026lt;= 3; j++ { fmt.Println(j) } k := 1 for k \u0026lt;= 3 { fmt.Println(k) k++ } s := \u0026#34;HellGo\u0026#34; for i, j := range s { fmt.Printf(\u0026#34;%d---\u0026gt;%v(%T)--\u0026gt;%c\\n\u0026#34;, i, j, j, j) // rune \t} // 死循环 \t//for { \t//\tfmt.Println(\u0026#34;666\u0026#34;) \t//} }   switch case 简化判断\na := 4 switch a { case a \u0026lt; 1: fmt.Println(\u0026quot;1\u0026quot;) case 2,3: fmt.Println(\u0026quot;2\u0026quot;) default: fmt.Println(\u0026quot;3\u0026quot;) // 3 } b := 3 switch a { case a \u0026lt; 1: fmt.Println(\u0026quot;1\u0026quot;) case 2,3: fmt.Println(\u0026quot;2\u0026quot;) fallthrough // 可以执行满足条件的case的下一个case, 了解即可 default: fmt.Println(\u0026quot;3\u0026quot;) } // 23 goto 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  func main() { for i := 1; i \u0026lt;= 9999; i++ { for j := 3000; j \u0026lt;= i; j++ { if j \u0026lt; i { fmt.Printf(\u0026#34;%d * %d = %d \u0026#34;, i, j, i*j) } else if j == i { fmt.Printf(\u0026#34;%d * %d = %d\\n\u0026#34;, i, j, i*j) goto breakTag } } } breakTag: // label \tfmt.Println(\u0026#34;end\u0026#34;) }   运算符 算数运算符: + - * / %\n关系运算符: == != \u0026gt; \u0026gt;= \u0026lt; \u0026laquo; (结果为bool值)\n逻辑运算符: \u0026amp;\u0026amp; || ! (结果为bool值)\n位运算符: \u0026amp; (相与 同为1为1)｜(相或 有1为1) ^（相异 或不同为1） \u0026laquo; (乘2的n次方) \u0026raquo; (除2的n次方)\n赋值运算符: 先其他运算再赋值\n5 \u0026lt;\u0026lt; 2 // 5 --- 101 左移 2 10100 --- 10 5 * 2^ 1 5 \u0026gt;\u0026gt; 2 // 5 --- 101 右移 2 001 --- 1 注: ++,-- 单独语句，不是运算符\n数组 var 数组变量名 [元素数量]T // 一旦定义，长度不能变 var a [3]int 数组初始化\nvar a1 [3]int //数组会初始化为int类型的零值 var a2 = [3]int{1,2} //使用指定的初始值完成初始化 var a3 = [...]int{1, 2} // 让编译器根据初始值的个数自行推断数组的长度 a4 := [...]int{1: 1, 3: 5} // 指定索引值的方式来初始化数组 [0, 1, 0 ,3] 数组遍历\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  package main import \u0026#34;fmt\u0026#34; func main() { var a = [...]int{1, 2, 3, 4, 5} // for循环遍历 \tfor i := 0; i \u0026lt; len(a); i++ { fmt.Println(a[i]) } // range \tfor i, j := range a { fmt.Println(i, j) } b := [...][2]int{ {1,2}, {2,1}, } for _, i := range b { for _, j := range i { fmt.Printf(\u0026#34;%d\\t\u0026#34;, j) } } }    数组是值类型，赋值和传参会复制整个数组。因此改变副本的值，不会改变本身的值。\n 切片slice 切片是引用类型，拥有相同类型元素的可变长度的序列\nvar 切片名 []切片类型 var name []string # 动态创建 make([]T, size, cap) // T 类型，size 长度， cap容量(从第一个到最后容量数)，cap 可省却 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  package main import \u0026#34;fmt\u0026#34; func main() { //var a []int \tvar c = []string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;} fmt.Println(len(c), cap(c)) d := make([]int, 2, 10) fmt.Println(len(d), cap(d)) e := d[3:6] fmt.Println(len(e), cap(e)) // 3， 3-10 7  s1 := make([]int, 3) // [0,0,0]  s2 := s1 // 拷贝前后两个变量共享底层数组，对一个切片的修改会影响另一个切片的内容 \ts2[0] = 100 fmt.Println(s1) fmt.Println(s2) // 遍历和for一样  for i := 0; i \u0026lt; len(s1); i++ { fmt.Printf(\u0026#34;%d\\t\u0026#34;, s1[i]) } for _, i := range s2 { fmt.Printf(\u0026#34;%d\\t\u0026#34;, i) } }    切片的本质就是对底层数组的封装\n append 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  package main import \u0026#34;fmt\u0026#34; func main() { var num []int for i := 0; i \u0026lt; 20; i++ { // 追加一个元素 \tnum = append(num, i) fmt.Printf(\u0026#34;%v len:%d cap:%d ptr:%p\\n\u0026#34;, num, len(num), cap(num), num) } // 追加多个元素  num = append(num, 1, 2, 3) fmt.Printf(\u0026#34;%v, \\n\u0026#34;, num) num1 := []int{99, 98} // 追加切片 \tnum = append(num, num1...) fmt.Println(num) }   copy copy(目标切片,源切片) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  func main() { // copy()复制切片 \ta := []int{1, 2, 3, 4, 5} c := make([]int, 5, 5) copy(c, a) //使用copy()函数将切片a中的元素复制到切片c \tfmt.Println(a) //[1 2 3 4 5] \tfmt.Println(c) //[1 2 3 4 5] \tc[0] = 1000 fmt.Println(a) //[1 2 3 4 5]  fmt.Println(c) //[1000 2 3 4 5]  var a = make([]string, 5, 10) // 已经有5个了 \tfor i := 0; i \u0026lt; 10; i++ { a = append(a, fmt.Sprintf(\u0026#34;%v\u0026#34;, i)) } fmt.Println(a, cap(a), len(a)) // [ 0 1 2 3 4 5 6 7 8 9] 20 15 }   指针  取地址 \u0026amp;a 根据地址取值 *b  make \u0026amp; new 都用来申请内存\nmake: slice，map， chan申请内存，返回类型本身 new: 基本数据类型申请内存, 返回指针, 且内存对应的值为类型零值 a := new(int) map 散列表(hash)实现, 无序的基于key-value的数据结构,引用类型，必须初始化才能使用.\nmap[KeyType]ValueType make(map[keytype]valuetype, [cap]) code := make(map[string]string, 10) code[\u0026quot;a\u0026quot;] = \u0026quot;a\u0026quot; code[\u0026quot;b\u0026quot;] = \u0026quot;b\u0026quot; # 判断 值是否存在 value, ok := map[key] if ok { // 存在 } else { // 不存在 } // 循环 for k, v := range map { // k,v v可省略 } 函数 func 函数名(参数)(返回值){ } 示例\nfunc sum1(x, y int) int { sum := x + y return sum } // 返回值定义了返回值名，return可省却 func sum2(x, y int) (sum int) { sum = x + y return } // 可变参数，可变参数可有可无 func sum3(x int, y ...int) { fmt.Println(x) fmt.Println(y) // 切片 } func main() { r1 := sum1(1, 2) r2 := sum2(1, 2) fmt.Println(r1, r2) sum3(1) // 1 [] sum3(1, 2) 1 [2] sum3(1, 2, 3) 1 [2,3] } defer 延迟处理, 多个defer 按照先进后出处理。\n函数return分成两步\n 返回值赋值 defer return  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63  package main import \u0026#34;fmt\u0026#34; func deferdemo(name string) { fmt.Println(name) } func f1() int { x := 5 defer func() { x++ // 修改x不是 返回值 \t}() // 返回值赋值 5 \t// 修改x值为 6 \t// retrun 5 \treturn x } func f2() (x int) { defer func() { x++ }() // 返回值赋值 x=5 \t// 修改x值为 x=6 \t// return 6  return 5 // 返回值 } func f3() (y int) { x := 5 defer func() { x++ }() // y = x = 5 \t// x = 6 \t// return y = 6  return x } func f4() (x int) { defer func(x int) { x++ }(x) // x = 5 \t// 副本 x = 6 \t// return x \treturn 5 } func main() { deferdemo(\u0026#34;666\u0026#34;) defer deferdemo(\u0026#34;777\u0026#34;) deferdemo(\u0026#34;888\u0026#34;) defer deferdemo(\u0026#34;999\u0026#34;) fmt.Println(f1(), f2(), f3(), f4()) // 5,6,5,5  }   匿名函数 1 2 3 4 5 6 7 8 9 10 11 12 13  // 多次执行 \te1 := func(x, y int) { fmt.Println(x) fmt.Println(y) fmt.Println(x + y) } e1(2, 4) // 立即执行，只执行一次 \tfunc(x, y int) { fmt.Println(x * y) }(1, 2)   闭包  函数作为返回值 外部变量引用  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  package main import \u0026#34;strings\u0026#34; import \u0026#34;fmt\u0026#34; // checkMail func checkMail(domain string) func(string) string { return func(name string) string { if strings.HasSuffix(name, domain) { return name } return name + \u0026#34;@\u0026#34; + domain } } func main() { talkFunc := checkMail(\u0026#34;@ysicing.me\u0026#34;) fmt.Println(talkFunc(\u0026#34;i\u0026#34;)) fmt.Println(talkFunc(\u0026#34;root@ysicing.me\u0026#34;)) }   panic/recover  recover()和defer一起使用 defer在panic语句前  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  package main import \u0026#34;fmt\u0026#34; func funcA() { fmt.Println(\u0026#34;a\u0026#34;) } func funcB() { defer func() { err := recover() fmt.Println(err) }() panic(\u0026#34;error\u0026#34;) fmt.Println(\u0026#34;b\u0026#34;) } func funC() { fmt.Println(\u0026#34;c\u0026#34;) } func main() { funcA() funcB() funC() }   占位符 \tm1 := make(map[string]int, 5) m1[\u0026quot;demo\u0026quot;] = 1 fmt.Printf(\u0026quot;%v\\n\u0026quot;, m1) // 值的默认格式 fmt.Printf(\u0026quot;%+v\\n\u0026quot;, m1) // 类似%v, 结构体会加字段名 fmt.Printf(\u0026quot;%#v\\n\u0026quot;, m1)\t// map[string]int{\u0026quot;demo\u0026quot;:1} 值Go语法 fmt.Printf(\u0026quot;%T\\n\u0026quot;, m1) // map[string]int 打印类型 结构体 ","description":"Go基础","id":7,"section":"posts","tags":["go"],"title":"Go基础","uri":"https://ysicing.me/posts/go-study-ch1/"},{"content":"helm 安装  安装docker时默认已经安装了helm,如果不是最新版本请upgrade-tools\n 1 2 3 4 5  docker pull ysicing/tools docker run --rm -v /usr/local/bin:/sysdir ysicing/tools tar zxf /pkg.tgz -C /sysdir # 版本 helm version version.BuildInfo{Version:\u0026#34;v3.1.2\u0026#34;, GitCommit:\u0026#34;d878d4d45863e42fd5cff6743294a11d28a9abce\u0026#34;, GitTreeState:\u0026#34;clean\u0026#34;, GoVersion:\u0026#34;go1.13.8\u0026#34;}   配置国内helm镜像库 1 2 3 4 5 6  # 自动 helminit # 手动 helm repo add stable http://mirror.azure.cn/kubernetes/charts/ helm repo add incubator http://mirror.azure.cn/kubernetes/charts-incubator/   ","description":"helm安装","id":8,"section":"posts","tags":["kubernetes","helm"],"title":"helm安装","uri":"https://ysicing.me/posts/helm-install/"},{"content":"部署docker registry  最近大陆push镜像老是超时，于是想自建一个，使用helm方式, 和drone安装方式类似\n 部署 helm pull stable/docker-registry tar xf docker-registry-1.9.1.tgz \u0026amp;\u0026amp; cd docker-registry/ # 编辑values.yaml,自定义配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64  # 注释部分为调整replicaCount:1updateStrategy:podAnnotations:{}podLabels:{}image:repository:registrytag:2.7.1pullPolicy:IfNotPresentservice:name:registrytype:ClusterIPport:5000annotations:{}ingress:enabled:true# 启用ingresspath:/hosts:- hub.local.godu.dev# 域名annotations:nginx.ingress.kubernetes.io/proxy-body-size:\u0026#34;0\u0026#34;# k8s ingress 413nginx.org/client-max-body-size:\u0026#34;0\u0026#34;# nginxnc ingress 413labels:{}tls:- secretName:godu.dev# 证书hosts:- hub.local.godu.dev# 域名resources:{}persistence:accessMode:\u0026#39;ReadWriteOnce\u0026#39;enabled:truesize:5GiexistingClaim:registry# 同dronestorage:filesystemsecrets:haSharedSecret:\u0026#34;\u0026#34;htpasswd:\u0026#34;\u0026#34;configData:version:0.1log:fields:service:registrystorage:cache:blobdescriptor:inmemoryhttp:addr::5000headers:X-Content-Type-Options:[nosniff]health:storagedriver:enabled:trueinterval:10sthreshold:3securityContext:enabled:truerunAsUser:1000fsGroup:1000priorityClassName:\u0026#34;\u0026#34;podDisruptionBudget:{}nodeSelector:{}tolerations:[]extraVolumeMounts:[]extraVolumes:[]  deploy\nhelm install registry -f values.yaml stable/docker-registry ","description":"helm部署docker registry","id":9,"section":"posts","tags":[""],"title":"helm部署docker registry","uri":"https://ysicing.me/posts/helm-docker-registry/"},{"content":"使用Helm安装Drone  一个比较热门的轻量级CI/CD开源工具：Drone\n 简介  Drone是用Go开发的开源轻量级CI/CD工具 使用简单的 YAML 配置文件来定义和执行 Docker 容器中定义的 Pipeline 构成简单,服务占用资源少  Server端负责身份认证，仓库配置，用户、Secrets 以及 Webhook 相关的配置 Agent端用于接受构建的作业和真正用于运行的 Pipeline 工作流   安装简单，支持主流Git托管服务(github,gitea等) 官方文档也很全  环境  helm v3.0.2 drone 1.6.1 k8s 1.17.0  准备工作 注册Github OAuth应用\n获取到github oauth Client ID,Client Secret留用。\n创建持久化存储 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  # https://ysicing.me/hack/demo/pvc.yamlapiVersion:v1kind:PersistentVolumemetadata:name:dronepvspec:accessModes:- ReadWriteOncecapacity:storage:2GipersistentVolumeReclaimPolicy:DeletestorageClassName:nfs-testnfs:server:192.168.100.101path:/k8sdata/default-drone-pvc---kind:PersistentVolumeClaimapiVersion:v1metadata:name:dronepvcnamespace:defaultspec:accessModes:- ReadWriteOnceresources:requests:storage:2GistorageClassName:nfs-test  示例\n# nfs 地址需要按需调整一下 kubectl apply -f https://ysicing.me/hack/demo/pvc.yaml kubectl get pvc 安装  本文使用helm方式安装，因为需要对配置做些调整，需要自定义一些配置\n 1 2 3 4 5  helm repo update # 获取最新的离线drone包 helm pull stable/drone tar xf drone-2.4.0.tgz \u0026amp;\u0026amp; cd drone # 编辑values.yaml   示例values.yaml如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102  # 有注释的地方说明有修改images:server:repository:\u0026#34;docker.io/drone/drone\u0026#34;tag:1.6.1pullPolicy:IfNotPresentagent:repository:\u0026#34;docker.io/drone/agent\u0026#34;tag:1.6.1pullPolicy:IfNotPresentdind:repository:\u0026#34;docker.io/library/docker\u0026#34;tag:18.06.1-ce-dindpullPolicy:IfNotPresentservice:httpPort:80type:ClusterIPexposeGRPC:falseingress:enabled:true# 启用hosts:- drone.godu.dev# 域名tls:- secretName:godu.dev# 证书，集群内已经证书的secret了，可以不启用，因为我的dev域名必须https访问hosts:- drone.godu.dev# 域名sourceControl:provider:github# githubsecret:github:clientID:xxx# github oauth id xxxclientSecretKey:clientSecretclientSecretValue:xxxx# github oauth secret xxxxserver:https://github.comgitlab:clientID:clientSecretKey:clientSecretclientSecretValue:server:gitea:clientID:clientSecretKey:clientSecretclientSecretValue:server:gogs:server:bitbucketCloud:clientID:clientSecretKey:clientSecretclientSecretValue:bitbucketServer:server:consumerKey:consumerKeyprivateKey:privateKeyusername:passwordKey:passwordserver:host:\u0026#34;drone.godu.dev\u0026#34;protocol:httpsrpcProtocol:httpadminUser:ysicing# github 登录后就具有管理员权限alwaysAuth:falsekubernetes:enabled:true# 运行 Drone 的任务的时候就是直接使用 Kubernetes 的 Job 资源对象来执行，而不是 Drone 的 agent.env:DRONE_LOGS_DEBUG:\u0026#34;false\u0026#34;DRONE_DATABASE_DRIVER:\u0026#34;sqlite3\u0026#34;DRONE_DATABASE_DATASOURCE:\u0026#34;/var/lib/drone/drone.sqlite\u0026#34;annotations:{}resources:{}affinity:{}nodeSelector:{}tolerations:[]extraContainers:| extraVolumes: |agent:env:DRONE_LOGS_DEBUG:\u0026#34;false\u0026#34;replicas:1annotations:{}resources:{}livenessProbe:{}readinessProbe:{}affinity:{}nodeSelector:{}tolerations:[]dind:enabled:truedriver:overlay2resources:{}metrics:prometheus:enabled:truepersistence:enabled:trueexistingClaim:dronepvc# 刚刚创建的持久化 pvcrbac:create:trueapiVersion:v1serviceAccount:create:truename:  部署drone\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  $ helm install drone -f values.yaml stable/drone $ helm status drone NAME: drone LAST DEPLOYED: Sun Jan 5 20:30:00 2020 NAMESPACE: default STATUS: deployed REVISION: 1 TEST SUITE: None NOTES: ********************************************************************************* *** PLEASE BE PATIENT: drone may take a few minutes to install *** ********************************************************************************* From outside the cluster, the server URL(s) are: http://drone.godu.dev   最后\nroot@k8s.cn1:~/drone/drone# kubectl get pods -l app=drone NAME READY STATUS RESTARTS AGE drone-drone-server-5bffbc56df-qzk28 1/1 Running 0 35m root@k8s.cn1:~/drone/drone# kubectl get ing -l app=drone NAME HOSTS ADDRESS PORTS AGE drone-drone drone.godu.dev 80, 443 36m 触发CI构建 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  # .drone.ymlkind:pipelinename:defaultsteps:- name:buildimage:golang:latestenvironment:GOPROXY:https://goproxy.cncommands:- CGO_ENABLED=0gobuild- name:dockerimage:plugins/dockersettings:repo:ysicing/godemouse_cache:trueusername:from_secret:dockeruserpassword:from_secret:dockertags:- latestwhen:event:pushbranch:master  代码地址: BeidouCloudPlatform/demo\nCli工具 brew install drone-cli export DRONE_SERVER=https://drone.godu.dev export DRONE_TOKEN=\u0026lt;token\u0026gt; drone info # 修复webhook，如果调整了域名，可以通过此命令修复webhook drone repo repair BeidouCloudPlatform/demo Job清理问题 因为使用Job的方式进行pipline操作，如果不启用TTLAfterFinished会导致job不会被自动清理。 开启feature请参考 feature开启\n默认drone清理是300s\n","description":"helm部署drone","id":10,"section":"posts","tags":["drone"],"title":"helm部署drone","uri":"https://ysicing.me/posts/helm-drone/"},{"content":"域名相关 默认情况下, 本地环境域名测试\n*.k7s.xyz 192.168.100.101 *.slb.k7s.xyz 192.168.100.102 *.vlb.k7s.xyz192.168.100.103 NGINX Ingress Controller (ingress-nginx) 使用helm方式安装\nkubectl apply -f https://ysicing.me/hack/helm/nginx-ingress/ns.yaml # 安装 helm install nginx-ingress -f https://ysicing.me/hack/helm/nginx-ingress/nginx-ingress-1.34.2.yaml stable/nginx-ingress -n ingress-nginx # 升级 helm upgrade nginx-ingress -f https://ysicing.me/hack/helm/nginx-ingress/nginx-ingress-1.34.2.yaml stable/nginx-ingress -n ingress-nginx NGINX Ingress Controllers (kubernetes-ingress) helm repo add nginx-stable https://helm.nginx.com/stable helm repo update helm install nginx-ingress -f https://ysicing.me/hack/helm/hack/helm/nginxnc-ingress/nginx-ingress-0.4.3.yaml nginx-stable/nginx-ingress -n ingress-nginx # 或者 kubectl apply -f https://ysicing.me/hack/k7s/install/nginx-ingress/nginx-ingress.yml 部署文档 nginxinc/kubernetes-ingress v1.6.0\n","description":"ingress安装","id":11,"section":"posts","tags":["kubernetes","ingress"],"title":"ingress安装","uri":"https://ysicing.me/posts/ingress-install/"},{"content":"k3s 是Rancher推出的轻量级 k8s.\n下载安装脚本 # 境外 curl -sfL https://get.k3s.io \u0026gt; install.sh # 大陆 curl -sfL https://docs.rancher.cn/k3s/k3s-install.sh \u0026gt; k3s-install.sh 安装master节点 INSTALL_K3S_EXEC=\u0026quot;--no-deploy traefik --node-ip 10.147.20.41 --docker\u0026quot; ./install.sh # 配置kubeconfig cp -a /etc/rancher/k3s/k3s.yaml /root/.kube/config 安装worker节点 # token 是从 master 节点的 /var/lib/rancher/k3s/server/node-token 文件里获取的。 K3S_TOKEN=K107941e2fbb3596e5678ee39c0ac875fe83bf97b05535f898e06d8881bf1a65212::server:380bb2b3064b115f110260aec43a72e3 K3S_URL=https://10.147.20.41:6443 INSTALL_K3S_MIRROR=cn INSTALL_K3S_EXEC=\u0026quot;--node-ip 10.147.20.43 --docker\u0026quot; ./k3s-install.sh 安装ingress ","description":"k3s 安装小记","id":12,"section":"posts","tags":["kubernetes","k3s"],"title":"k3s 安装小记","uri":"https://ysicing.me/posts/k3s-install/"},{"content":"minikube安装k8s MacOS安装 1  brew install minikube   1 2  # PROXY可以根据自己需要设置，可不设置 minikube start --cpus=2 --memory 4g --disk-size=40g --driver=virtualbox --image-repository=registry.cn-hangzhou.aliyuncs.com/google_containers --nodes=2 --docker-env HTTP_PROXY=http://192.168.99.1:7890 --docker-env HTTPS_PROXY=http://192.168.99.1:7890 --docker-env NO_PROXY=127.0.0.1/32,192.168.0.0/16,10.0.0.0/8,172.16.0.0/12,localhost   ","description":"minikube安装k8s","id":13,"section":"posts","tags":["kubernetes","安装"],"title":"minikube安装k8s","uri":"https://ysicing.me/posts/k8s-minikube-install/"},{"content":"NFS存储 Debian # 安装 apt update apt install -y nfs-kernel-server # 配置 mkdir /k8sdata echo \u0026quot;/k8sdata/ *(insecure,rw,sync,no_root_squash,no_subtree_check)\u0026quot; \u0026gt; /etc/exports # 启动nfs systemctl enable rpcbind systemctl enable nfs-server systemctl start rpcbind systemctl start nfs-server exportfs -r # 测试 showmount -e 127.0.0.1 CentOS # 安装nfs yum install -y nfs-utils # 配置共享目录 mkdir /k8sdata echo \u0026quot;/k8sdata *(insecure,rw,sync,no_root_squash)\u0026quot; \u0026gt; /etc/exports # 启动nfs systemctl enable rpcbind systemctl enable nfs-server systemctl start rpcbind systemctl start nfs-server exportfs -r # 测试 showmount -e 127.0.0.1 一键部署nfs且配置默认存储 # 未安装存储 curl https://ysicing.me/hack/k7s/install/nfs/deploy.sh | bash # 已有存储 wget https://ysicing.me/hack/k7s/install/nfs/deploy_exist_nfs.sh ./deploy_exist_nfs.sh \u0026lt;ip\u0026gt; \u0026lt;path\u0026gt; ","description":"NFS存储","id":14,"section":"posts","tags":["kubernetes","安装"],"title":"NFS存储","uri":"https://ysicing.me/posts/nfs-install-k8s/"},{"content":"OpenLDAP安装初体验  简介这里不在描述，google即可\n docke快速部署 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  version:\u0026#39;2\u0026#39;services:openldap:image:osixia/openldap:1.3.0container_name:openldapenvironment:LDAP_LOG_LEVEL:\u0026#34;256\u0026#34;LDAP_ORGANISATION:\u0026#34;Godu Inc.\u0026#34;LDAP_DOMAIN:\u0026#34;ysicing.me\u0026#34;LDAP_BASE_DN:\u0026#34;\u0026#34;LDAP_ADMIN_PASSWORD:\u0026#34;meadmin\u0026#34;LDAP_CONFIG_PASSWORD:\u0026#34;meconfig\u0026#34;LDAP_READONLY_USER:\u0026#34;true\u0026#34;LDAP_READONLY_USER_USERNAME:\u0026#34;readonly\u0026#34;LDAP_READONLY_USER_PASSWORD:\u0026#34;readonly\u0026#34;LDAP_RFC2307BIS_SCHEMA:\u0026#34;false\u0026#34;LDAP_BACKEND:\u0026#34;mdb\u0026#34;LDAP_TLS:\u0026#34;false\u0026#34;LDAP_REPLICATION:\u0026#34;false\u0026#34;KEEP_EXISTING_CONFIG:\u0026#34;false\u0026#34;LDAP_REMOVE_CONFIG_AFTER_SETUP:\u0026#34;true\u0026#34;LDAP_SSL_HELPER_PREFIX:\u0026#34;ldap\u0026#34;tty:truestdin_open:trueports:- \u0026#34;389:389\u0026#34;- \u0026#34;636:636\u0026#34;domainname:\u0026#34;ldap.ysicing.me\u0026#34;# important: same as hostname# hostname: \u0026#34;ldap.ysicing.me\u0026#34;command:[\u0026#34;--copy-service\u0026#34;,\u0026#34;--loglevel\u0026#34;,\u0026#34;debug\u0026#34;]phpldapadmin:image:osixia/phpldapadmin:latestcontainer_name:phpldapadminenvironment:PHPLDAPADMIN_LDAP_HOSTS:\u0026#34;openldap\u0026#34;PHPLDAPADMIN_HTTPS:\u0026#34;false\u0026#34;ports:- \u0026#34;8080:80\u0026#34;depends_on:- openldap  验证 din openldap ldapsearch -x -H ldap://localhost -b dc=ysicing,dc=me -D 'cn=admin,dc=ysicing,dc=me' -w meadmin 或者访问127.0.0.1:8080\n","description":"OpenLDAP安装初体验","id":15,"section":"posts","tags":["ldap"],"title":"OpenLDAP安装初体验","uri":"https://ysicing.me/posts/openldap-install/"},{"content":" 推荐使用sealos, 一键高可用，简单上手, 安装k8s 1.18.2版本\n 准备工作 虚拟机 环境: 3台机器(debian/buster, 11.11.11.111~11.11.11.113, 2核4G80G存储)\n1  ergo init vm --vmname k8s --vmnum 3   初始化环境 ergo init debian --ip 11.11.11.111 --ip 11.11.11.112 --ip 11.11.11.113 安装docker ergo install docker --ip 11.11.11.111 --ip 11.11.11.112 --ip 11.11.11.113 ergo install tools --ip 11.11.11.111 --ip 11.11.11.112 --ip 11.11.11.113 安装k8s  说明，我定制了sealos和calico版本为最新版本,且使用了在线安装包\n # 安装了k8s 1.18.2, 安装了ingress, 配置nfs，默认存储类为nfs-data ergo install k8s --enablenfs=true --mip 11.11.11.111 --wip 11.11.11.112-11.11.11.113 ","description":"sealos安装k8s","id":16,"section":"posts","tags":["kubernetes","安装"],"title":"sealos安装k8s","uri":"https://ysicing.me/posts/sealos-install-k8s/"},{"content":"定时任务，如每65分钟执行一次 crontab 定时任务 65 分钟执行一次，怎么写？\n这个时候，用系统自带的crontab就不好实现了,这时候就是systemd该上场了\n参考Systemd 定时器教程\ncat /etc/systemd/system/example.timer [Unit] Description=example timer [Timer] OnUnitActiveSec=1h Unit=example.service [Install] WantedBy=multi-user.target cat /etc/systemd/system/example.service [Unit] Description=example [Service] ExecStart=\u0026lt;相关命令\u0026gt; [Install] WantedBy=multi-user.target 定制定时器\nOnActiveSec：定时器生效后，多少时间开始执行任务 OnBootSec：系统启动后，多少时间开始执行任务 OnStartupSec：Systemd 进程启动后，多少时间开始执行任务 OnUnitActiveSec：该单元上次执行后，等多少时间再次执行 OnUnitInactiveSec： 定时器上次关闭后多少时间，再次执行 OnCalendar：基于绝对时间，而不是相对时间执行 AccuracySec：如果因为各种原因，任务必须推迟执行，推迟的最大秒数，默认是60秒 Unit：真正要执行的任务，默认是同名的带有.service后缀的单元 Persistent：如果设置了该字段，即使定时器到时没有启动，也会自动执行相应的单元 WakeSystem：如果系统休眠，是否自动唤醒系统 Timer和Service大体用法一致\n","description":"Systemd 定时器教程","id":17,"section":"posts","tags":["冷知识"],"title":"Systemd 定时器教程","uri":"https://ysicing.me/posts/systemd-timers/"},{"content":"安装vim plug curl -fLo ~/.vim/autoload/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim 写配置 向~/.vimrc写入\n\u0026quot; autocmd BufWritePost $MYVIMRC source $MYVIMRC \u0026quot; 关闭兼容模式 set nocompatible \u0026quot; 设置行号 set nu \u0026quot;突出显示当前行,列 set cursorline set cursorcolumn \u0026quot;显示括号匹配 set showmatch \u0026quot; tab 缩进 set tabstop=4 \u0026quot; 设置Tab长度为4空格 set shiftwidth=4 \u0026quot; 设置自动缩进长度为4空格 set autoindent \u0026quot; 继承前一行的缩进方式，适用于多行注释 \u0026quot; 定义快捷键的前缀，即\u0026lt;Leader\u0026gt; let mapleader=\u0026quot;;\u0026quot; \u0026quot; ==== 系统剪切板复制粘贴 ==== \u0026quot; v 模式下复制内容到系统剪切板 vmap \u0026lt;Leader\u0026gt;c \u0026quot;+yy \u0026quot; n 模式下复制一行到系统剪切板 nmap \u0026lt;Leader\u0026gt;c \u0026quot;+yy \u0026quot; n 模式下粘贴系统剪切板的内容 nmap \u0026lt;Leader\u0026gt;v \u0026quot;+p \u0026quot; 开启实时搜索 set incsearch \u0026quot; 搜索时大小写不敏感 set ignorecase syntax enable syntax on \u0026quot; 开启文件类型侦测 filetype plugin indent on \u0026quot; 启用自动补全 \u0026quot; 退出插入模式指定类型的文件自动保存 au InsertLeave *.go,*.sh,*.php write \u0026quot; 插件 call plug#begin('~/.vim/plugged') \u0026quot; 可以快速对齐的插件 Plug 'junegunn/vim-easy-align' \u0026quot; 用来提供一个导航目录的侧边栏 Plug 'scrooloose/nerdtree' \u0026quot; 可以在导航目录中看到 git 版本信息 Plug 'Xuyuanp/nerdtree-git-plugin' \u0026quot; 自动补全括号的插件，包括小括号，中括号，以及花括号 Plug 'jiangmiao/auto-pairs' \u0026quot; 可以在 vim 中使用 tab 补全 Plug 'vim-scripts/SuperTab' Plug 'majutsushi/tagbar' \u0026quot; go 主要插件 Plug 'fatih/vim-go', { 'tag': '*' } \u0026quot; go 中的代码追踪，输入 gd 就可以自动跳转 Plug 'dgryski/vim-godef' call plug#end() 安装插件 vim ~/.vimrc # 安装插件 :PlugInstall # 更新插件 :PlugUpdate ","description":"vim配置","id":18,"section":"posts","tags":["vim"],"title":"vim配置","uri":"https://ysicing.me/posts/vim-config/"},{"content":"vscode配置 安装好Go相关插件，配置工具包 使用command+shift+P快捷键,然后键入Go: Install/Update Tools选中全部(根据需要),稍等片刻，就会安装完成。\n自定义配置项 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  { \u0026#34;git.autofetch\u0026#34;: true, \u0026#34;files.autoSave\u0026#34;: \u0026#34;onWindowChange\u0026#34;, \u0026#34;workbench.colorTheme\u0026#34;: \u0026#34;Go - Sources\u0026#34;, \u0026#34;terminal.integrated.shell.osx\u0026#34;: \u0026#34;/bin/zsh\u0026#34;, \u0026#34;go.autocompleteUnimportedPackages\u0026#34;: true, \u0026#34;go.gocodeAutoBuild\u0026#34;: true, \u0026#34;go.useLanguageServer\u0026#34;: true, \u0026#34;goOutliner.enableDebugChannel\u0026#34;: true, \u0026#34;goOutliner.extendExplorerTab\u0026#34;: true, \u0026#34;go.inferGopath\u0026#34;: true, \u0026#34;go.docsTool\u0026#34;: \u0026#34;godoc\u0026#34;, \u0026#34;go.gocodePackageLookupMode\u0026#34;: \u0026#34;go\u0026#34;, \u0026#34;go.gotoSymbol.includeImports\u0026#34;: true, \u0026#34;go.useCodeSnippetsOnFunctionSuggest\u0026#34;: true, //使用代码片段提示 \u0026#34;go.useCodeSnippetsOnFunctionSuggestWithoutType\u0026#34;: true, \u0026#34;go.formatTool\u0026#34;: \u0026#34;goimports\u0026#34;, //代码格式化 // \u0026#34;go.buildOnSave\u0026#34;: true, //保存代码时自动编译 \u0026#34;go.lintOnSave\u0026#34;: \u0026#34;file\u0026#34;, //保存代码时优化 \u0026#34;go.vetOnSave\u0026#34;: \u0026#34;package\u0026#34;, //保存代码时检查潜在错误 \u0026#34;go.coverOnSave\u0026#34;: false //保存代码时执行测试 }   ","description":"vscode配置","id":19,"section":"posts","tags":["vscode","go"],"title":"vscode配置","uri":"https://ysicing.me/posts/vscode-config/"},{"content":"使用nvm进行node版本管理 安装nvm 1 2 3 4 5 6 7 8 9 10 11 12 13  # 安装 curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.2/install.sh | bash # 默认会写.zshrc ### .zshrc nvm start export NVM_DIR=\u0026#34;$HOME/.nvm\u0026#34; [ -s \u0026#34;$NVM_DIR/nvm.sh\u0026#34; ] \u0026amp;\u0026amp; \\. \u0026#34;$NVM_DIR/nvm.sh\u0026#34; # This loads nvm [ -s \u0026#34;$NVM_DIR/bash_completion\u0026#34; ] \u0026amp;\u0026amp; \\. \u0026#34;$NVM_DIR/bash_completion\u0026#34; # This loads nvm bash_completion ### .zshrc nvm end source .zshrc nvm install node # \u0026#34;node\u0026#34; is an alias for the latest version   ","description":"使用nvm进行node版本管理","id":20,"section":"posts","tags":["nodejs"],"title":"使用nvm进行node版本管理","uri":"https://ysicing.me/posts/nodejs-install/"},{"content":" 内网穿透之wireguard\n 安装 Debian # Debian Bullseye 之前版本都需要启用backports源来支持安装 apt install wireguard -y macOS brew install wireguard-tools 配置服务端 cd /etc/wireguard # 创建服务端密钥对 umask 077 wg genkey | tee privatekey | wg pubkey \u0026gt; publickey # 创建wg0.conf cat \u0026gt; /etc/wireguard/wg0.conf \u0026lt;\u0026lt;EOF [Interface] PrivateKey = \u0026lt;Private Key\u0026gt; Address = 10.0.0.1/24, fd86:ea04:1115::1/64 ListenPort = 51820 PostUp = iptables -A FORWARD -i wg0 -j ACCEPT; iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE; ip6tables -A FORWARD -i wg0 -j ACCEPT; ip6tables -t nat -A POSTROUTING -o eth0 -j MASQUERADE PostDown = iptables -D FORWARD -i wg0 -j ACCEPT; iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE; ip6tables -D FORWARD -i wg0 -j ACCEPT; ip6tables -t nat -D POSTROUTING -o eth0 -j MASQUERADE SaveConfig = true EOF # 启动 wg-quick up wg0 # 开机启动 systemctl enable wg-quick@wg0 # 检查 wg show 配置客户端 umask 077 wg genkey | tee privatekey | wg pubkey \u0026gt; publickey cat \u0026gt; /etc/wireguard/wg0.conf \u0026lt;\u0026lt;EOF [Interface] PrivateKey = \u0026lt;Output of privatekey file that contains your private key\u0026gt; Address = 10.0.0.2/24, fd86:ea04:1115::5/64 EOF 连接客户端和服务端 法一 客户端操作  wg-quick down wg0 直接编辑客户端配置文件 启动wg-quick up wg0;systemctl enable wg-quick@wg0  # /etc/wireguard/wg0.conf 新增 [Peer] PublicKey = \u0026lt;Server Public key\u0026gt; Endpoint = \u0026lt;Server Public IP\u0026gt;:51820 AllowedIPs = 10.0.0.2/24, fd86:ea04:1115::5/64 法二 服务端操作 wg set wg0 peer \u0026lt;Client Public Key\u0026gt; endpoint \u0026lt;Client IP address\u0026gt;:51820 allowed-ips 203.0.113.12/24,fd86:ea04:1115::5/64 问题解决 # 1. 内核模块没有 lsmod | grep wireguard \u0026amp;\u0026amp; echo yes || echo no no modprobe wireguard modprobe: FATAL: Module wireguard not found in directory /lib/modules/5.4.0-0.bpo.4-amd64 dkms status wireguard, 0.0.20200318, 4.19.0-8-amd64, x86_64: installed uname -a Linux cn3 5.4.0-0.bpo.4-amd64 #1 SMP Debian 5.4.19-1~bpo10+1 (2020-03-09) x86_64 GNU/Linux dkms autoinstall Error! Your kernel headers for kernel 5.4.0-0.bpo.4-amd64 cannot be found. Please install the linux-headers-5.4.0-0.bpo.4-amd64 package # 解决方式 apt install -y linux-headers-5.4.0-0.bpo.4-amd64 # ipv6 RTNETLINK answers: Permission denied 启用ipv6即可 net.ipv6.conf.all.disable_ipv6=0 ","description":"内网穿透之wireguard","id":21,"section":"posts","tags":["wireguard","内网穿透"],"title":"内网穿透之wireguard","uri":"https://ysicing.me/posts/wireguard-install/"},{"content":"初始化Debian  基础环境配置和安装docker配置\n all.yaml: 系统+docker docker.yaml: 安装docker init.yaml: 系统 命令行工具  仅使用debian系统\n ergo init debian -h 宿主机初始化 git clone https://github.com/ysicing/play-ansible.git cd play-ansible # 安装ansible,如果已安装可跳过 ./install.sh # 配置初始化机器 cp inventory.ini.example inventory.ini # 执行初始化 ansible-playbook init.yml 容器化方式初始化 1 2 3 4 5 6  docker pull ysicing/ansible docker run -it --rm ysicing/ansible bash cp inventory.ini.example inventory.ini # 初始化系统 ansible-playbook init.yml exit   ","description":"初始化Debian","id":22,"section":"posts","tags":["debian","安装"],"title":"初始化Debian","uri":"https://ysicing.me/posts/debian-init/"},{"content":"背景  一条命令快速重装干净的Linux环境 目前仅支持Debian(不会不打算支持其他系统) 基于萌咖大佬的二次魔改  默认做了  默认root密码 vagrant(安装完成建议修改，禁止密码登录) 默认配置源为mirrors.tuna.tsinghua.edu.cn,默认添加了security,backports 默认时区为Asia/Shanghai 默认安装了curl wget openssh-server sudo sed apt-transport-https net-tools等常用工具 同时默认支持自定义密码  安装 1 2 3  curl -sSL https://ysicing.me/hack/reinstall/install.sh | bash # 指定参数 bash \u0026lt;(wget --no-check-certificate -qO- \u0026#39;https://ysicing.me/hack/reinstall/install.sh\u0026#39;) -p thah6oob7KieChie   自定义硬盘  存在多个硬盘时，需要下载 https://ysicing.me/hack/reinstall/installhk.sh文件，编辑如下部分即可\n 1  d-i partman-auto/disk string /dev/sdb   参考附录 [ Linux VPS ] Debian/Ubuntu/CentOS 网络安装/重装系统/纯净安装 一键脚本\n","description":"在线重装Debian","id":23,"section":"posts","tags":["debian","安装"],"title":"在线重装Debian","uri":"https://ysicing.me/posts/debian-reinstall/"},{"content":" 主要是用于linux安装\n 安装,配置 1 2 3 4 5 6 7 8 9 10 11 12 13  # 下载 wget https://dl.google.com/go/go1.13.6.linux-amd64.tar.gz # 解压 tar -C /usr/local -xzf go1.13.3.linux-amd64.tar.gz # 配置 .bashrc export GO111MODULE=on export GOPROXY=https://goproxy.cn export GOPATH=\u0026#34;/root/go\u0026#34; export GOBIN=\u0026#34;$GOPATH/bin\u0026#34; export PATH=$PATH:$GOBIN:/usr/local/go/bin source .bashrc # 验证 go env   一键脚本 1  curl https://ysicing.me/hack/install/go.sh | bash   ","description":"安装golang","id":24,"section":"posts","tags":["go","安装"],"title":"安装golang","uri":"https://ysicing.me/posts/go-install/"},{"content":"ttlSecondsAfterFinished 自动清理完成和失败的Job，目前该特性默认不启用。如何判断未启用,查看job资源，在spec里未发现ttlSecondsAfterFinished定义则表示未启用。\n启用 我的集群使用sealos安装的，其配置文件在 /etc/kubernetes/manifests下,分别调整 kube-apiserver.yaml,kube-controller-manager.yaml,kube-scheduler.yaml配置，新增\n# 示例 spec: containers: - command: - kube-scheduler - --authentication-kubeconfig=/etc/kubernetes/scheduler.conf - --authorization-kubeconfig=/etc/kubernetes/scheduler.conf - --bind-address=127.0.0.1 - --kubeconfig=/etc/kubernetes/scheduler.conf - --leader-elect=true - --feature-gates=TTLAfterFinished=true # 新增配置 image: k8s.gcr.io/kube-scheduler:v1.17.0 调整完成后稍等片刻,相关pod会重建。\n","description":"开启集群feature","id":25,"section":"posts","tags":["kubernetes"],"title":"开启集群feature开启集群feature","uri":"https://ysicing.me/posts/k8s-feature/"},{"content":"docker npm安装问题 npm config set unsafe-perm true git操作 # 改崩了 git fetch --all git reset --hard origin/master # 放弃本地全部/单个 git checkout . git checkout -- filename ","description":"知识点","id":26,"section":"posts","tags":["冷知识"],"title":"知识点","uri":"https://ysicing.me/posts/faq/"},{"content":" 通过Operator创建Prometheus\n 为什么需要prometheus-operator  因为是prometheus主动去拉取的,所以在k8s里pod因为调度的原因导致pod的ip会发生变化,人工不可能去维持,自动发现有基于DNS的,但是新增还是有点麻烦。Prometheus-operator的本职就是一组用户自定义的CRD资源以及Controller的实现，Prometheus Operator这个controller有RBAC权限下去负责监听这些自定义资源的变化，并且根据这些资源的定义自动化的完成如Prometheus Server自身以及配置的自动化管理工作。在Kubernetes中我们使用Deployment、DamenSet，StatefulSet来管理应用Workload，使用Service，Ingress来管理应用的访问方式，使用ConfigMap和Secret来管理应用配置。我们在集群中对这些资源的创建，更新，删除的动作都会被转换为事件(Event)，Kubernetes的Controller Manager负责监听这些事件并触发相应的任务来满足用户的期望。这种方式我们成为声明式，用户只需要关心应用程序的最终状态，其它的都通过Kubernetes来帮助我们完成，通过这种方式可以大大简化应用的配置管理复杂度。而除了这些原生的Resource资源以外，Kubernetes还允许用户添加自己的自定义资源(Custom Resource)。并且通过实现自定义Controller来实现对Kubernetes的扩展,不需要用户去二开k8s也能达到给k8s添加功能和对象。因为svc的负载均衡,所以在K8S里监控metrics基本最小单位都是一个svc背后的pod为target,所以prometheus-operator创建了对应的CRD: kind: ServiceMonitor ,创建的ServiceMonitor里声明需要监控选中的svc的label以及metrics的url路径的和namespaces即可 (摘自@张馆长)\n 部署 # 在之前的基础上，配置了存储storageclass git clone https://github.com/ysicing/prometheus.git cd prometheus # prometheus-service/prometheus-storageclass.yaml #配置存储 bash -x ./deploy.sh # 在管理节点执行，如有报错，在执行一下 与官方的区别支持了数据持久化和域名配置,部分监控组件如etcd等\n","description":"通过Operator创建Prometheus","id":27,"section":"posts","tags":["kubernetes","prometheus"],"title":"通过Operator创建Prometheus","uri":"https://ysicing.me/posts/prometheus-install/"},{"content":"阿里云轻量应用服务器升级内核  升级有风险请慎重哦\n 配置说明  阿里云HK 1核1G1TB30Mbps ¥24/m\nDebian 9.9\n 更新源  需要移除默认源，使用如下源\n # 需要添加buster-backports源 sed -i \u0026quot;s#stretch#buster#g\u0026quot; /etc/apt/sources.list # 示例 deb http://mirrors.a li yun c/debian/ buster main contrib non-free deb http://mirrors.aliyun.com/debian/ buster-updates main contrib non-free deb http://mirrors.aliyun.com/debian/ buster-proposed-updates main non-free contrib deb http://mirrors.aliyun.com/debian/ buster-backports main non-free contrib deb http://mirrors.aliyun.com/debian-security/ buster/updates main non-free contrib 更新升级\n1 2  apt-get update apt-get dist-upgrade -y   升级到最新内核 apt-get install -t buster-backports linux-image-amd64 -y update-grub apt autoclean apt autoremove -y reboot 升级完成后docker无法启动 prior storage driver aufs failed: driver not supported 删除/var/lib/docker，docker存储由aufs变成overlay2\n","description":"阿里云轻量应用服务器升级内核","id":28,"section":"posts","tags":["debian",""],"title":"阿里云轻量应用服务器升级内核","uri":"https://ysicing.me/posts/aliyun-debian-upgrade-kernel/"},{"content":" 不会具体讲怎么部署，原理都类似,将原先amd64换成mips64el\n 中标麒麟龙芯CPU源 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  # /etc/yum.repos.d/ns7-mips.repo [ns7-mips64el-os] name=NeoKylin Linux Advanced Server 7 - $basearch - Os baseurl=http://download.cs2c.com.cn/neokylin/server/releases/7.0/ls_64/ gpgcheck=0 gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-neokylin-release enabled=1 [ns7-mips64el-extras] name=NeoKylin Linux Advanced Server 7 - Addons baseurl=http://download.cs2c.com.cn/neokylin/server/everything/7.0/ls_64/ gpgcheck=0 gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-neokylin-release enabled=0 [ns7-mips64el-updates] name=NeoKylin Linux Advanced Server 7 - Updates baseurl=http://download.cs2c.com.cn/neokylin/server/updates/7.0/ls_64/ gpgcheck=0 gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-neokylin-release enabled=1   还有一个就是龙芯自己的仓库比较迷，但是软件包比较新\n1  http://ftp.loongnix.org/os/loongnix/1.0/   基础镜像 neokylin基础镜像 1 2 3 4 5 6 7  wget https://raw.githubusercontent.com/docker/docker/master/contrib/mkimage-yum.sh chmod +x ./mkimage-yum.sh ./mkimage-yum.sh -y /etc/yum.conf nk-base wget http://list.isoftos.win/script/create_docker_image.loogson chmod +x create_docker_image.loogson ./create_docker_image.loogson nk-base   debian基础镜像 可以通过异构构建镜像方式\n可以参考大佬项目 debian-debootstrap\nk8s编译 宿主机编译  4核16G,性能太差,源码编译安装go新版本差不多两小时\n 通过异构镜像编译 大概修改印象:\n1 2 3 4 5 6 7 8 9 10 11 12 13  # 第一处 mips64*) host_arch=mips64le ;; # 第二处 \u0026#34;linux/mips64le\u0026#34;) export CGO_ENABLED=1 export CC=mips64el-linux-gnu-gcc ;; # 第三处 linux/mips64le # 第四处 uint64转换一下   具体可以通过make \u0026lt;xxx组件名\u0026gt;\npause镜像 这个得注意一下, 不能用空镜像，可以使用基础镜像\n","description":"龙芯Mips64el平台上部署K8s","id":29,"section":"posts","tags":[""],"title":"龙芯Mips64el平台上部署K8s","uri":"https://ysicing.me/posts/mips64el-loongson-k8s/"},{"content":" 姑且算我的博客吧，🐶!\n 托管 目前博客部署在Ucloud 🇭🇰 k8s集群上\n集群  *.godu.dev 大陆🇨🇳k8s集群 *.ysicing.me 香港🇭🇰k8s集群 *.k7s.xyz 本地k8s集群  ","description":"关于","id":30,"section":"","tags":null,"title":"关于","uri":"https://ysicing.me/about/"},{"content":"macOS 常用工具  个人常用工具列表\n  iTerm2(终端) Sourcetree(git工具) Dash(文档工具) iHosts(hosts编辑器) Microsoft To Do(Todo) pap.er(壁纸) ZeroTier(内网穿透) Xmind Pixiu(记账)  ","description":"记录自用macOS常用工具","id":33,"section":"links","tags":[""],"title":"macOS常用工具","uri":"https://ysicing.me/links/macos-apps/"},{"content":" 用于记录发现的有用/有趣的Github项目\n 20191219  book prometheus  20191208  kubewatch Watch k8s events and trigger Handlers Go  20191121  overlay networking tool slackhq/nebula  20191104  KubeOperator 一键部署和管理生产级别的 Kubernetes 集群  20191010  Status Page statusfy NodeJS  20191009  Status Page statping Go  20191006  iptv  20190927  Collection of Prometheus alerting rules  20190926  listen1 听歌神器  20190925  一个基于Go的Telegram RSS Bot机器人，支持应用内阅读预览 kubernetes app kubeapp  20190924  octant k8s Go  20190920  gopub 发布系统(不维护) PrometheusAlert Go  20190919  felix SSH and RESTful scaffold for Backend and DevOps engineers Go kplcloud基于Kubernetes的应用管理平台 Go Git服务webhook Go  20190916  🕵️‍♀️ 监视我的手机：数据都去哪儿了？ Python  20190915  🍭 集合多家 API 的新一代图床auxpi Go  20190913  TeaWeb-可视化的Web代理服务 Go  20190912  SmartPing 一款开源、高效、便捷的网络质量监控神器！Go  20190911  Mysql web端sql审核平台Yearning Go 简单可信赖的任务管理工具 Go  20190908  Linux透明代理 运维管理平台flask Python  20190906  kubernetes高可用安装工具sealos GO 基于Vue框架构建的github数据可视化平台GitDataV VUE  20190904  nging 基于caddy的网站服务程序，带图形化管理界面  20190903  Aria2-AriaNg-X docker-compose  20190823  trivy 容器的简单而全面的漏洞扫描程序 Go  20190813  anytunnel 开源内网穿透商用平台系统 Go 扩展企业安全测试主动诱导型蜜罐框架系统 Go  ","description":"用于记录发现的有用/有趣的Github项目","id":34,"section":"links","tags":[""],"title":"有趣的Github项目","uri":"https://ysicing.me/links/links/"}]